// Modified Mario Cako
// CS451
// 11/19/2017
// hw4


// Copyright 2011 Bill Campbell, Swami Iyer and Bahar Akbal-Delibas

// This is the input file to JavaCC for generating a scanner and 
// a parser for j--. From the specification in this file, JavaCC,  
// among other files, generates a JavaCCParser.java file 
// under $j/j--/src/jminusminus. This file is the parser. The code 
// between  PARSER_BEGIN( JavaCCParser ) and 
// PARSER_END( JavaCCParser ) is copied verbatim to this file. JavaCC 
// also generates a JavaCCParserTokenManager.java file which is the 
// scanner.

PARSER_BEGIN( JavaCCParser )

package jminusminus;

import java.util.ArrayList;

/**
 * Parser generated by JavaCC. It parses a j-- compilation unit 
 * (program file), taking tokens from the scanner (also generated by 
 * JavaCC), and produces an abstract syntax tree (AST) for it.
 */

class JavaCCParser {
    /** Whether a parser error has been found. */
    private boolean errorHasOccurred;
        
    /** Name of the file that is parsed. */     
    private String fileName;
        
    /**
     * Pull out the ambiguous part of a name and return it. 
     * 
     * @param name with an ambiguos part (possibly).
     * @return ambiguous part or null.
     */
    
    private AmbiguousName ambiguousPart( TypeName name ) {
        String qualifiedName = name.toString();
        int lastDotIndex = qualifiedName.lastIndexOf( '.' );
        return lastDotIndex == -1
            ? null // It was a simple name
            : new AmbiguousName( name.line(),
                qualifiedName.substring( 0, lastDotIndex ) );
    }

    /**
     * Report a syntax error.
     * 
     * @param message message identifying the error.
     * @param args related values.
     */

    private void reportParserError( String message, Object... args ) {
        errorHasOccurred = true;
        System.err.printf( "%s:%d: ", fileName, token.beginLine );
        System.err.printf( message, args );
        System.err.println();
    }
        
    /**
     * Recover from the parser error that occurred by skipping to 
     * any of the specified tokens. 
     *
     * Current error recovery mechanism is rather simple-minded and is 
     * based on skipping all the tokens until a SEMI or an EOF is 
     * encountered. This scheme can be enhanced by passing in the 
     * FOLLOW-SET of the non-terminal at hand.
     * 
     * @param skipTo array of tokens that we could skip to.
     * @param e exception that is raised by JavaCC in the event 
     * of a parser error.
     */
         
    private void recoverFromError( int[] skipTo, ParseException e ) {   
        // Get the possible expected tokens
        StringBuffer expected = new StringBuffer();
        for ( int i = 0; i < e.expectedTokenSequences.length; i++ ) {
            for ( int j = 0; j < e.expectedTokenSequences[ i ].length; 
                j++ ) {
                expected.append( "\n" );
                expected.append( "    " );
                expected.append( tokenImage[ 
                    e.expectedTokenSequences[ i ][ j ] ] );
                expected.append( "..." );
            }    
        }    

        // Print error message
        if ( e.expectedTokenSequences.length == 1 ) {
            reportParserError( "\"%s\" found where %s sought", 
                getToken( 1 ), expected );
        }
        else {
            reportParserError( "\"%s\" found where one of %s sought", 
                getToken( 1 ), expected );
        }

        // Recover
        boolean loop = true;              
        do {
            token = getNextToken(); 
            for ( int i = 0; i < skipTo.length; i++ ) {
                if ( token.kind == skipTo[ i ] ) {
                    loop = false;
                    break;
                }
            }
        } while( loop );
    }   

    /** 
     * Set the name of the file that is being parsed. 
     *
     * @param fileName name of the file.
     */
         
    public void fileName( String fileName ) {               
        this.fileName = fileName;
    }

    /**
     * Has a parser error occurred up to now?
     * 
     * @return true or false.
     */

    public boolean errorHasOccurred() {
        return errorHasOccurred;
    }   
}

PARSER_END( JavaCCParser )

/////////////////////////////////////////////////////////
//         The j-- lexical grammar starts here         //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\t"|"\n"|"\r"|"\f"}

// Single line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}

// Multiline cooment -- ignored
SKIP: {<MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">}

// Reserved words
TOKEN:
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < CHAR: "char" >
| < CLASS: "class" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < IF: "if" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < SUPER: "super" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
| < BREAK: "break">
| < BYTE: "byte">
| < CASE: "case">
| < CATCH: "catch" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < DEF: "default" >
| < DO:"do">
| < DOUBLE:"double">
| < FINAL:"final">
| < FINALLY:"finally">
| < FLOAT:"float">
| < FOR:"for">
| < GOTO:"goto">
| < IMPLEMENTS:"implements">
| < INTERFACE:"interface">
| < LONG:"long">
| < NATIVE:"native">
| < SHORT:"short">
| < STRICTFP:"strictfp">
| < SWITCH:"switch">
| < SYNCHRONIZED:"synchronized">
| < THROW:"throw">
| < THROWS:"throws">
| < TRANSIENT:"transient">
| < TRY:"try">
| < VOLATILE:"volatile">
}

// Operators (these could be combined with the reserved words)
TOKEN:
{
  < PLUS: "+" >
| < ASSIGN: "=" >
| < DEC: "--" >
| < EQUAL: "==" >
| < GT: ">" >
| < INC: "++" >
| < LAND: "&&" >
| < LE: "<=" >
| < LNOT: "!" >
| < MINUS: "-" >
| < PLUS_ASSIGN: "+=" >
| < STAR: "*" >
| < NOT_EQUAL:"!=">
| < DIV_ASSIGN:"/=">
| < MINUS_ASSIGN:"-=">
| < STAR_ASSIGN:"*=">
| < REM_ASSIGN:"%=">
| < SHR_ASSIGN:">>=">
| < USHR_ASSIGN:">>>=">
| < GTE:">=">
| < SHL_ASSIGN:"<<=">
| < LT:"<">
| <	XOR_ASSIGN:"^=">
| < OR_ASSIGN:"|=">
| < LOR:"||">
| < AND_ASSIGN:"&=">
| < TERNARY:"?">
| < DIV: "/">
| < REM:"%">
| < SHL:"<<">
| < SHR:">>">
| < USHR:">>>">
| < OR:"|">
| < XOR :"^">
| < AND:"&">
| < NOT:"~">

}

// Separators (these could be combined with the reserved words)
TOKEN:
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LCURLY: "{" >
| < RCURLY: "}" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < SEMI: ";" >
| < COMMA: "," >
| < DOT: "." >
| < COLON:":">
}

// Identifiers
TOKEN:
{
  < IDENTIFIER: (<LETTER>|"_"|"$") (<LETTER>|<DIGIT>|"_"|"$")* >
| < #LETTER: ["a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| < #NON_ZERO_DIGIT: ["1"-"9"] >
| < #SUFFIX_DOUBLE: ("d"|"D") >
| < #SUFFIX_FLOAT: ("f"|"F") >
| < #SUFFIX_LONG: ("l"|"L") >
// (e|E) [(+|-)] Digits
| < #EXPONENT: ("e"|"E") (<PLUS>|<MINUS>)? (<DIGIT>)(<DIGIT>)* >
}

// Literals
TOKEN:
{
  < INT_LITERAL: ("0" | <NON_ZERO_DIGIT> (<DIGIT>)*) >
  | < LONG_LITERAL: (<INT_LITERAL>) <SUFFIX_LONG> >
  
// double type
  | < DOUBLE_LITERAL: ( 

  			// Digit [digits] . [digits] [exponent] [suffix for double]
			 (<DIGIT>) (<DIGIT>)* <DOT> (<DIGIT>)* (<EXPONENT>)? (<SUFFIX_DOUBLE>)?

			 // . digit [digits] [exponent] [suffix for double]
			| <DOT> (<DIGIT>) (<DIGIT>)* (<EXPONENT>)? (<SUFFIX_DOUBLE>)? 

			// digit [digits] exponent [suffix for double]
			| (<DIGIT>) (<DIGIT>)* <EXPONENT> (<SUFFIX_DOUBLE>)? 

			// digit [digits] [exponent] suffix for double
			| (<DIGIT>) (<DIGIT>)* (<EXPONENT>)? <SUFFIX_DOUBLE>
	) >

// float type same as double but with a different suffix
  | < FLOAT_LITERAL: ( 
  			// Digit [digits] . [digits] [exponent] [suffix for float]
			 (<DIGIT>) (<DIGIT>)* <DOT> (<DIGIT>)* (<EXPONENT>)? (<SUFFIX_FLOAT>)?

			// . digit [digits] [exponent] [suffix for float]
			| <DOT> (<DIGIT>) (<DIGIT>)* (<EXPONENT>)? (<SUFFIX_FLOAT>)? 

			// digit [digits] exponent [suffix for float]
			| (<DIGIT>)(<DIGIT>)* <EXPONENT> (<SUFFIX_FLOAT>)? 

			// digit [digits] [exponent] suffix for float
			| (<DIGIT>)(<DIGIT>)* (<EXPONENT>)? <SUFFIX_FLOAT>
	) >

| < CHAR_LITERAL: "'" (<ESC> | ~["'","\\","\n","\r"]) "'" >
| < STRING_LITERAL: "\"" (<ESC> | ~["\"","\\","\n","\r"])* "\"" >   
| < #ESC: "\\" ["n","t","b","r","f","\\","'","\""] >
}

// For anything else, we return an ERROR token. Without this 
// definition the TokenManager will throw an Error when a lexical 
// error occurs, making it impossible to recover from it. So we 
// define this ERROR token. 
TOKEN:
{
 < ERROR: ~[] >
}

/////////////////////////////////////////////////////////
//       The j-- syntactic grammar starts here         //
/////////////////////////////////////////////////////////

/**
 * Parse a compilation unit (a program file) and construct an AST 
 * for it. After constructing the Parser, this is its entry point.
 * 
 * <pre>
 *   compilationUnit ::= [PACKAGE qualifiedIdentifier SEMI]
 *                       {IMPORT  qualifiedIdentifier SEMI}
 *                       {typeDeclaration}
 *                       EOF 
 * </pre>
 * 
 * @return an AST for a compilationUnit.
 */

public JCompilationUnit compilationUnit(): {
    int line = 0;
    TypeName packageName = null; // Default
    TypeName anImport = null;
    ArrayList<TypeName> imports = 
        new ArrayList<TypeName>();
    JAST aTypeDeclaration = null;
    ArrayList<JAST> typeDeclarations = new ArrayList<JAST>();
}
{
    try {
        [ 
            <PACKAGE> { line = token.beginLine; }
            packageName = qualifiedIdentifier() 
            <SEMI> 
        ]
        (
            <IMPORT> { line = line == 0 ? token.beginLine : line; }
            anImport = qualifiedIdentifier() 
            { imports.add( anImport ); } 
            <SEMI>
        )*
        (
            aTypeDeclaration = typeDeclaration()
            {
                line = line == 0 ? aTypeDeclaration.line() : line;
                typeDeclarations.add( aTypeDeclaration );
            }
        )*
        <EOF> { line = line == 0 ? token.beginLine : line; }
    } 
    catch ( ParseException e ) {
        recoverFromError( new int[] { SEMI, EOF }, e );
    }
    { 
        return new JCompilationUnit( fileName, line, 
            packageName, imports, typeDeclarations ); 
    }
}

/**
 * Parse a qualified identifier.
 * 
 * <pre>
 *   qualifiedIdentifier ::= IDENTIFIER {DOT IDENTIFIER}
 * </pre>
 * 
 * @return an instance of TypeName.
 */

private TypeName qualifiedIdentifier(): {
    int line = 0;
    String qualifiedIdentifier = "";
}
{
    try {
        <IDENTIFIER> 
        { 
            line = token.beginLine; 
            qualifiedIdentifier = token.image; 
        }
        ( 
            <DOT> <IDENTIFIER> 
            { qualifiedIdentifier += "." + token.image; } 
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return 
         new TypeName( line, qualifiedIdentifier ); }
}

/**
 * Parse a type declaration.
 * 
 * <pre>
 *   typeDeclaration ::= modifiers classDeclaration
 * </pre>
 * 
 * @return an AST for a typeDeclaration.
 */

private JAST typeDeclaration(): {
    ArrayList<String> mods = null;
    JAST classDeclaration = null;
}
{
    try {
        mods = modifiers()
        classDeclaration = classDeclaration( mods ) | 
        classDeclaration = interfaceDeclaration( mods )

    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return classDeclaration; }
}

/**
 * Parse modifiers.
 * 
 * <pre>
 *   modifiers ::= {PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT}
 * </pre>
 * 
 * Check for duplicates, and conflicts among access modifiers (public,
 * protected, and private). Otherwise, no checks.
 * 
 * @return a list of modifiers.
 */

private ArrayList<String> modifiers(): {
    ArrayList<String> mods = new ArrayList<String>();
    boolean scannedPUBLIC = false;
    boolean scannedPROTECTED = false;
    boolean scannedPRIVATE = false;
    boolean scannedSTATIC = false;
    boolean scannedABSTRACT = false;
}
{
    try {
    (   
        <PUBLIC> 
        { 
            mods.add( "public" );
            if ( scannedPUBLIC ) {
                reportParserError( "Repeated modifier: public" );
            }
            if ( scannedPROTECTED || scannedPRIVATE ) {
                reportParserError( "Access conflict in modifiers" );
            }
            scannedPUBLIC = true;
        } |
        <PROTECTED> 
        { 
            mods.add( "protected" );
            if ( scannedPROTECTED ) {
                reportParserError( "Repeated modifier: protected" );
            }
            if ( scannedPUBLIC || scannedPRIVATE ) {
                reportParserError( "Access conflict in modifiers" );
            }
            scannedPROTECTED = true;
        } |
        <PRIVATE> 
        { 
            mods.add( "private" );
            if ( scannedPRIVATE ) {
                reportParserError( "Repeated modifier: private" );
            }
            if ( scannedPUBLIC || scannedPROTECTED ) {
                reportParserError( "Access conflict in modifiers" );
            }
            scannedPRIVATE = true;
        } |
        <STATIC> 
        { 
            mods.add( "static" );
            if ( scannedSTATIC ) {
                reportParserError( "Repeated modifier: static" );
            }
            scannedSTATIC = true;
        } |
        <ABSTRACT> 
        { 
            mods.add( "abstract" );
            if ( scannedABSTRACT ) {
                reportParserError( "Repeated modifier: abstract" );
            }
            scannedABSTRACT = true;
        } 
    )*                  
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return mods; }
}

/**
 * Parse a class declaration.
 * 
 * <pre>
 *   classDeclaration ::= CLASS IDENTIFIER 
 *                        [EXTENDS qualifiedIdentifier]
 *						  [implements qualifiedIdentifier {, qualifiedIdentifier}]
 *                        classBody
 * </pre>
 * 
 * A class which doesn't explicitly extend another (super) class 
 * implicitly extends the superclass java.lang.Object.
 * 
 * @param mods the class modifiers.
 * @return an AST for a classDeclaration.
 */
     
private JClassDeclaration classDeclaration( ArrayList<String> mods ): {
    int line = 0;
    String name = "";
    Type superClass = Type.OBJECT;
    TypeName  typeName = null;
    ArrayList<JMember> classBody = null;
}
{
    try {
        <CLASS> { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
        [ 
            <EXTENDS> superClass = qualifiedIdentifier()
        ]
        [
        	<IMPLEMENTS> 
        	typeName = qualifiedIdentifier()
        	
        ]

        classBody = classBody()           
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { 
        return new JClassDeclaration( line, mods, 
            name, superClass, typeName, classBody ); 
    }
}


/**
 * Parse an interface declaration.
 * 
 * <pre>
 *   interfaceDeclaration ::= interface IDENTIFIER 
 *                        [EXTENDS qualifiedIdentifier {, qualifiedIdentifier}] 
 *                        interfaceBody
 * </pre>
 * 
 * A class which doesn't explicitly extend another (super) class 
 * implicitly extends the superclass java.lang.Object.
 * 
 * @param mods the interfaceDeclaration modifiers.
 * @return an AST for a interfaceDeclaration.
 */
     
private JInterfaceDeclaration interfaceDeclaration( ArrayList<String> mods ): {
    int line = 0;
    String name = "";
    ArrayList<TypeName> superClass = null;
    ArrayList<JMember> interfaceBody = null;
}
{
    try {
        <INTERFACE> { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
        [ 
            <EXTENDS> { superClass.add(qualifiedIdentifier()); }
        ]
        interfaceBody = interfaceBody()           
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { 
        return new JInterfaceDeclaration( line, mods, 
            name, superClass, interfaceBody ); 
    }
}



/**
 * Parse an interface body.
 * 
 * <pre>
 *   interfaceBody ::= LCURLY
 *                   {modifiers interfaceMemberDecl}
 *                 RCURLY
 * </pre>
 * 
 * @return list of members in the interface body.
 */

private ArrayList<JMember> interfaceBody(): {
    ArrayList<String> mods = null;
    JMember aMember = null;
    ArrayList<JMember> members = new ArrayList<JMember>();
    int line;
    JBlock body = null;
}
{
    try {
    	<LCURLY>
			( 
				mods = modifiers()
		        aMember = interfaceMemberDecl( mods ) { members.add( aMember ); } 
		    )*
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return members; }
}

/**
 * Parse a interface member declaration.
 * 
 * <pre>
 *   interfaceMemberDecl ::= 
 *                | (VOID | type) IDENTIFIER  // method
 *                    formalParameters
 *                    SEMI
 *                | type variableDeclarators SEMI 
 * </pre>
 * 
 * @param mods the interface member modifiers.
 * @return an AST for a interfaceMemberDecl.
 */
    
private JMember interfaceMemberDecl( ArrayList<String>  mods ): {
    int line = 0;
    Type type = null;
    String name = "";
    ArrayList<JFormalParameter> params = null;
    JBlock body = null;
    ArrayList<JVariableDeclarator> variableDeclarators = null;
    JMember memberDecl = null;
    ArrayList<TypeName> qualIdentifier = new ArrayList<TypeName>();
    TypeName typeName = null;
}
{
    try {
        LOOKAHEAD( ( <VOID> | type() ) <IDENTIFIER> <LPAREN> )
        (
            ( 
                <VOID> { type = Type.VOID; } | 
                type = type() 
            ) 
            { line = token.beginLine; }
            <IDENTIFIER> { name = token.image; } 
            params = formalParameters()
            
             // optional throws
            [
                //LOOKAHEAD( <THROWS> <IDENTIFIER> ) 
                <THROWS> 
                typeName = qualifiedIdentifier()
                { qualIdentifier.add(typeName); }
                ( 
                    <COMMA> typeName = qualifiedIdentifier() 
                    { qualIdentifier.add(typeName); }
                )*
            ]

            <SEMI> 
            { 
                memberDecl = 
                   new JMethodDeclaration( line, mods, name, 
                                           type, params, qualIdentifier, body ); 
            } 
        ) 

        | ( 
            type = type() { line = token.beginLine; }
            variableDeclarators = variableDeclarators( type )
            <SEMI>
            { 
                memberDecl = new JFieldDeclaration( line, mods, 
                    variableDeclarators ); 
            }
        )
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return memberDecl; }
}



/**
 * Parse a class body.
 * 
 * <pre>
 *   classBody ::= LCURLY
 *                   {modifiers memberDecl}
 *                 RCURLY
 * </pre>
 * 
 * @return list of members in the class body.
 */

private ArrayList<JMember> classBody(): {
    ArrayList<String> mods = null;
    JMember aMember = null;
    ArrayList<JMember> members = new ArrayList<JMember>();
    int line;
    JBlock body = null;
}
{
    try {
    	<LCURLY> (
	    	LOOKAHEAD (<STATIC> <LCURLY>)(
	    		<STATIC>(
	        	{line = token.beginLine; }
	        	body = block(){
	        		members.add(new JStaticBlock(line,body));
	        	}
	        )) |
	        //<LCURLY>(
	        	{line = token.beginLine;}
	        	body = block(){
	        		members.add(new JInstanceBlock(line, body));
	        	}
			// ) 
    	|
			( 
				mods = modifiers()
		        aMember = memberDecl( mods ) { members.add( aMember ); } 
		    )

	    )*
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return members; }
}

/**
 * Parse a member declaration.
 * 
 * <pre>
 *   memberDecl ::= IDENTIFIER            // constructor
 *                    formalParameters
 *                    block
 *                | (VOID | type) IDENTIFIER  // method
 *                    formalParameters
 *                    (block | SEMI)
 *                | type variableDeclarators SEMI 
 * </pre>
 * 
 * @param mods the class member modifiers.
 * @return an AST for a memberDecl.
 */
    
private JMember memberDecl( ArrayList<String>  mods ): {
    int line = 0;
    Type type = null;
    String name = "";
    ArrayList<JFormalParameter> params = null;
    JBlock body = null;
    ArrayList<JVariableDeclarator> variableDeclarators = null;
    JMember memberDecl = null;
    ArrayList<TypeName> qualIdentifier = new ArrayList<TypeName>();
    TypeName typeName = null;
}
{
    try {
        LOOKAHEAD( <IDENTIFIER> <LPAREN> )
        (
            <IDENTIFIER> 
            { 
                line = token.beginLine; 
                name = token.image; 
            } 
            params = formalParameters() 
            // optional throws
             [
	            //LOOKAHEAD( <THROWS> <IDENTIFIER>) 
	            <THROWS> 
	            typeName = qualifiedIdentifier(){
                 qualIdentifier.add(typeName); }
	            ( 
	            	<COMMA> typeName = qualifiedIdentifier() 
	            	{ qualIdentifier.add(typeName); }
	            )*
        	]

            body = block()
            { 
                memberDecl = 
                new JConstructorDeclaration( line, mods, 
                                             name, params,qualIdentifier, body );
            }
        ) |     
        LOOKAHEAD( ( <VOID> | type() ) <IDENTIFIER> <LPAREN> )
        (
            ( 
                <VOID> { type = Type.VOID; } | 
                type = type() 
            ) 
            { line = token.beginLine; }
            <IDENTIFIER> { name = token.image; } 
            params = formalParameters() 

             // optional throws
            [
	            //LOOKAHEAD( <THROWS> <IDENTIFIER> ) 
	            <THROWS> 
	            typeName = qualifiedIdentifier()
	            { qualIdentifier.add(typeName); }
	            ( 
	            	<COMMA> typeName = qualifiedIdentifier() 
	            	{ qualIdentifier.add(typeName); }
	            )*
        	]

            ( 
                body = block() | 
                <SEMI> 
            )
            { 
                memberDecl = 
                   new JMethodDeclaration( line, mods, name, 
                                           type, params, qualIdentifier, body ); 
            } 
        ) | 
        ( 
            type = type() { line = token.beginLine; }
            variableDeclarators = variableDeclarators( type )
            <SEMI>
            { 
                memberDecl = new JFieldDeclaration( line, mods, 
                    variableDeclarators ); 
            }
        )
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return memberDecl; }
}

/**
 * Parse a block.
 * 
 * <pre>
 *   block ::= LCURLY {blockStatement} RCURLY 
 * </pre>
 * 
 * @return an AST for a block.
 */

private JBlock block(): {
    int line = 0;
    JStatement aStatement = null;
    ArrayList<JStatement> statements = new ArrayList<JStatement>();
}
{
    try {
        <LCURLY> { line = token.beginLine; } 
        (
            aStatement = blockStatement()
            { statements.add( aStatement ); }
        )*
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return new JBlock( line, statements ); }
}

/**
 * Parse a block statement.
 * 
 * <pre>
 *   blockStatement ::= localVariableDeclarationStatement
 *                    | statement
 * </pre>
 * 
 * @return an AST for a blockStatement.
 */

private JStatement blockStatement(): {
    JStatement statement = null;
}
{       
    try {
        LOOKAHEAD( type() <IDENTIFIER> )
        statement = localVariableDeclarationStatement() |
        statement =  statement() 
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return statement; }
}

/**
 * Parse a statement.
 * 
 * <pre>
 *   statement ::= block
 *               | IF parExpression statement [ELSE statement]
 *               | WHILE parExpression statement 
 *               | RETURN [expression] SEMI
 *				 | for ( [ forInit ] ; [ expression ] ; [ forUpdate ]) statement
 *  			 | for ( type <identifier> : expression ) statement
 *               | SEMI 
 *               | statementExpression SEMI
 *				 | throw expression ;
 *
 * 	 forInit ::= statementExpression { , statementExpression }
 *				| [ final ] type variableDeclarators
 *	
 *   forUpdate ::= statementExpression { , statementExpression }
 * </pre>
 * 
 * @return an AST for a statement.
 */

private JStatement statement(): {
	
// others
    int line = 0;
    JStatement statement = null;
    JExpression test = null;
    JStatement consequent = null;
    JStatement alternate = null;
    JStatement body = null;
    JExpression expr = null;


// for loop
    ArrayList<JStatement> forInit = new ArrayList<JStatement>();
    ArrayList<JStatement> forUpdate = new ArrayList<JStatement>();
    ArrayList<JVariableDeclarator> variable = new ArrayList<JVariableDeclarator>();
    JExpression expression;
    JExpression forLoopExpression;
    JBlock statements = null; 
    JBlock forLoopBody = null;
    JFormalParameter forLoopFormalParameter;
    JStatement statementExpression = null;
    Type type = null;


// try catch finally 
	JBlock tryBody = null;
	JBlock catchBlock = null;
	ArrayList<JBlock> catchBody	= new ArrayList<JBlock>();
	JBlock finallyBody = null;
    ArrayList<JFormalParameter> tryCatchFinallyFormalParameters = new ArrayList<JFormalParameter>();
    JFormalParameter tryCatchFinallyFormalParameter;

}
{       
    try {
        statement = block() |
        <IF> { line = token.beginLine; }
        test = parExpression() 
        consequent = statement() 

        // Even without the lookahead below, which is added to 
        // suppress JavaCC warnings, dangling if-else problem is 
        // resolved by binding the alternate to the closest 
        // consequent.
        [ 
            LOOKAHEAD( <ELSE> ) 
            <ELSE> alternate = statement() 
        ]
        { statement = 
            new JIfStatement( line, test, consequent, alternate ); } |
        <WHILE> { line = token.beginLine; }
        test = parExpression() 
        body = statement()
        { statement = new JWhileStatement( line, test, body ); } |
        <TRY> { line = token.beginLine; }
			/*

			else if(have(TRY)){
			        	// try block {catch (formalParamater) block}
			        		//[finally block] // must be pressent if no catches

			        	JBlock tryBody = block();
						ArrayList<JFormalParameter> formalParameters = new ArrayList<JFormalParameter>();
						ArrayList<JBlock> catchBody = new ArrayList<JBlock>();
						JBlock finallyBody = null;

						if (see(CATCH)){
				        	while(have(CATCH)){
				        		mustBe(LPAREN);
				        		formalParameters.add(formalParameter());
				        		mustBe(RPAREN);
				        		catchBody.add(block());
				        		//mustBe(RCURLY); block takes care of the RCURLY
				        	}
			        	}
			        	if(have(FINALLY)){
			        		finallyBody = block();
			        	}
			        	return new JTryStatementOp(line,tryBody,formalParameters, catchBody, finallyBody);
			        }
			*/        
			        tryBody = block()

			        //LOOKAHEAD( <CATCH> ) 
			        (
				        <CATCH>
				        (
				        	<LPAREN>
				        	tryCatchFinallyFormalParameter = formalParameter()
				        	{ tryCatchFinallyFormalParameters.add(tryCatchFinallyFormalParameter); }
				        	<RPAREN>
				        )
				        	catchBlock = block()
				        	{ catchBody.add(catchBlock); }
			        )*
			        // optional finally
			        [
				        <FINALLY>
				        finallyBody = block()
			        ]

			 { statement = new JTryStatementOp( line, tryBody, tryCatchFinallyFormalParameters, catchBody, finallyBody ); } |
        <RETURN> { line = token.beginLine; }
        [ 
            expr = expression() 
        ] 
        <SEMI>
        { statement = new JReturnStatement( line, expr ); } |
        // Start of for loop enhanced and regular
	    <FOR> { line = token.beginLine; }   
	    <LPAREN>
	    (

	    // enhanced
	    // for(type <identifier> : expression ) statement
	    	LOOKAHEAD( (type()) <IDENTIFIER> <COLON>)
	    	(
	        	forLoopFormalParameter = formalParameter()
	        	<COLON>
	        	forLoopExpression = expression()
	        	<RPAREN>
	        	forLoopBody = block()
	        	{ statement = 
	           		  new JEnhancedForStatementOp(line, forLoopFormalParameter, forLoopExpression, forLoopBody); }
	        ) |
	        // regular for loop starts
	        // here i have: for ( ....
	        // so if i look ahead for next token and i find a semi then i have an optional forInit
	        // for ( [ forInit ] ; [ forLoopExpression ] ; [ forUpdate ]) statement
	        //			||
	        //		<-----
	        (
	        	(
	        		LOOKAHEAD( <SEMI> )
	        		// for init is empty
	       			{ forInit = new ArrayList<JStatement>(); }
	        		
	        		|
	        		// for is one of the two versions
	        		
	        		// forInit ::= statementExpression {COMMA statementExpression}
	           	 	// | [FINAL] type variableDeclarators

	           	 	// so we go into forInit logic to update the initialization part
	        		(
	        			// type variableDeclarators
	        			LOOKAHEAD((type()) <IDENTIFIER>) 
	        			(	
							type = type()
							variable = variableDeclarators(type)
							{forInit.add(new JForInitDeclarationOp(line, variable));}
						) 

						|

						// forInit ::= statementExpression {COMMA statementExpression}
				       	( 
				       	  statementExpression = statementExpression()
				       	  { forInit.add( statementExpression ); }
				       	  (
				            <COMMA> statementExpression = statementExpression()
				            { forInit.add( statementExpression ); }
				       	  )*
				       	)
	        		)
	       		)

	       		// for loop continues on with optional testing expression
	        	// here we are at the expression part of the normal for loop where 
	        	// its the middle part of the for loop
	        	// for ( [ forInit ] ; [ forLoopExpression ] ; [ forUpdate ]) statement
	        	//								||
	        	//			<---------------------
	       		<SEMI>
				(
					LOOKAHEAD( <SEMI> )
					{ forLoopExpression = null; }
					|	
	       			forLoopExpression = expression()
	       		)

	       		// for loop continues on with optional update part
	        	// here we reached the forUpdate
	        	// for ( [ forInit ] ; [ forLoopExpression ] ; [ forUpdate ]) statement
	        	//													||
	        	//					  			<---------------------
	       		<SEMI>
	       		(
	       			LOOKAHEAD( <RPAREN> )
	       			// forUpdate is empty
	       			{ forUpdate = new ArrayList<JStatement>(); }
	       			|
	       			// non empty update part reached
	       			// forUpdate ::= statementExpression {COMMA statementExpression}
	       			( [
				      	statementExpression = statementExpression()
			    	  	{ forUpdate.add( statementExpression ); }
			      		(
			       		   <COMMA> statementExpression = statementExpression()
			         	 	{ forUpdate.add( statementExpression ); }
			      		)*
			   		] )
	       		)

	       		// end of regular for loop reached with the RPAREN
	       		<RPAREN>

	       		// then we can either use block or statements for the body of the for loop
	       		forLoopBody = block()        
	       		{ statement = 
	           		  new JForStatementOp(line, forInit, forLoopExpression, forUpdate, forLoopBody);}
	        )
	    ) |
	    <THROW>
	    { line = token.beginLine;}
	    /* got this from my parser class for reference
		else if(have(THROW)){
        	JExpression expression = expression();
        	mustBe(SEMI);
        	return new JThrowStatementOp(line,expression);
	    */
        	expr = expression() 
        <SEMI>
        { statement = new JThrowStatementOp( line, expr ); } |
	    <SEMI> 
	    	{ statement = new JEmptyStatement( line ); } |
	        // Must be a statementExpression
	        statement = statementExpression() 
	        <SEMI>	
	    } 
	    catch ( ParseException e ) { 
	        recoverFromError( new int[] { SEMI, EOF }, e ); 
	    }
	    { return statement; }
}



/**
 * Parse formal parameters.
 * 
 * <pre>
 *   formalParameters ::= LPAREN 
 *                          [formalParameter 
 *                            {COMMA  formalParameter}]
 *                        RPAREN
 * </pre>
 * 
 * @return a list of formal parameters.
 */

private ArrayList<JFormalParameter> formalParameters(): {
    ArrayList<JFormalParameter> parameters = 
        new ArrayList<JFormalParameter>();
    JFormalParameter aParameter = null;
}
{
    try {
        <LPAREN>
        [ 
            aParameter = formalParameter()
            { parameters.add( aParameter ); }
            ( 
                <COMMA> aParameter = formalParameter()
                { parameters.add( aParameter ); }
            )* 
        ]
        <RPAREN>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return parameters; }
}

/**
 * Parse a formal parameter.
 * 
 * <pre>
 *   formalParameter ::= type IDENTIFIER
 * </pre>
 * 
 * @return an AST for a formalParameter.
 */

private JFormalParameter formalParameter(): {
    int line = 0;
    Type type = null;
    String name = "";
}
{
    try {
        type = type() { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JFormalParameter( line, name, type ); }
}

/**
 * Parse a parenthesized expression.
 * 
 * <pre>
 *   parExpression ::= LPAREN expression RPAREN
 * </pre>
 * 
 * @return an AST for a parExpression.
 */

private JExpression parExpression(): {
    JExpression expr = null;

}
{
    try {
        <LPAREN> expr = expression() <RPAREN>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return expr; }
}

/**
 * Parse a local variable declaration statement.
 * 
 * <pre>
 *   localVariableDeclarationStatement ::= type 
 *                                           variableDeclarators 
 *                                             SEMI
 * </pre>
 * 
 * @return an AST for a variableDeclaration.
 */

private JVariableDeclaration localVariableDeclarationStatement(): {
    int line = 0;
    Type type = null;
    ArrayList<JVariableDeclarator> vdecls = null;
    ArrayList<String> mods = new ArrayList<String>();
}
{
    try {
        type = type() { line = token.beginLine; }
        vdecls = variableDeclarators( type ) <SEMI>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return new JVariableDeclaration( line, mods, vdecls ); }
}

/**
 * Parse variable declarators.
 * 
 * <pre>
 *   variableDeclarators ::= variableDeclarator 
 *                             {COMMA variableDeclarator}
 * </pre>
 * 
 * @param type type of the variables.
 * @return a list of variable declarators.
 */

private ArrayList<JVariableDeclarator> 
    variableDeclarators( Type type ): {
    JVariableDeclarator aVariableDeclarator = null;
    ArrayList<JVariableDeclarator> variableDeclarators =
        new ArrayList<JVariableDeclarator>();
}
{
    try {
        aVariableDeclarator = variableDeclarator( type )
        { variableDeclarators.add( aVariableDeclarator ); }
        (
            <COMMA> aVariableDeclarator = variableDeclarator( type )
            { variableDeclarators.add( aVariableDeclarator ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return variableDeclarators; }
}

/**
 * Parse a variable declarator.
 * 
 * <pre>
 *   variableDeclarator ::= IDENTIFIER
 *                          [ASSIGN variableInitializer]
 * </pre>
 * 
 * @param type type of the variable.
 * @return an AST for a variableDeclarator.
 */

private JVariableDeclarator variableDeclarator( Type type ): {
    int line = 0;
    JExpression initial = null;
    String name = "";
}
{
    try {
        <IDENTIFIER> { line = token.beginLine; name = token.image; }
        [ 
            <ASSIGN> initial = variableInitializer( type ) 
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return new JVariableDeclarator( line, name, type, initial ); }
}

/**
 * Parse a variable initializer.
 * 
 * <pre>
 *   variableInitializer ::= arrayInitializer
 *                         | expression
 * </pre>
 * 
 * @param type type of the variable.
 * @return an AST for a variableInitializer.
 */

private JExpression variableInitializer( Type expected ): {
    JExpression initializer = null;
}
{
    try {
        initializer = arrayInitializer( expected ) |
        initializer = expression()
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return initializer; }
}

/**
 * Parse an array initializer.
 * 
 * <pre>
 *   arrayInitializer ::= LCURLY 
 *                          [variableInitializer 
 *                            {COMMA variableInitializer} [COMMA]]
 *                        RCURLY 
 * </pre>
 * 
 * @param type type of the array.
 * @return an AST for an arrayInitializer.
 */

private JArrayInitializer arrayInitializer( Type expected ): {
    int line = 0; 
    ArrayList<JExpression> initials = new ArrayList<JExpression>();
    JExpression anInitializer = null;
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        [ 
            anInitializer = 
              variableInitializer( expected.componentType() ) 
            { initials.add( anInitializer ); }
            ( 
                <COMMA> anInitializer = 
                    variableInitializer( expected.componentType() ) 
                { initials.add( anInitializer ); } 
            )* 
        ] 
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JArrayInitializer( line, expected, initials ); }
}

/**
 * Parse arguments.
 * 
 * <pre>
 *   arguments ::= LPAREN [expression {COMMA expression}] RPAREN    
 * </pre>
 * 
 * @return a list of expressions.
 */

private ArrayList<JExpression> arguments(): {
    ArrayList<JExpression> args = new ArrayList<JExpression>();
    JExpression anExpression = null;
}
{
    try {
        <LPAREN>
        [ 
            anExpression = expression() { args.add( anExpression ); } 
            ( 
                <COMMA> anExpression = expression() 
                { args.add( anExpression ); } 
            )*
        ] 
        <RPAREN>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return args; }
}

/**
 * Parse a type.
 * 
 * <pre>
 *   type ::= referenceType 
 *          | basicType
 * </pre>
 * 
 * @return an instance of Type.
 */
     
private Type type(): {
    Type type = null;
}
{
    try {
        LOOKAHEAD( <IDENTIFIER> | basicType() <LBRACK> <RBRACK> )
        type = referenceType() |
        type = basicType()
    } 
    catch ( ParseException e ) { 
       recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return type; }
}

/**
 * Parse a basic type.
 * 
 * <pre>
 *   basicType ::= BOOLEAN | CHAR | INT | DOUBLE
 * </pre>
 * 
 * @return an instance of Type.
 */

private Type basicType(): {
    Type type = Type.ANY;
}
{
    try {
        <BOOLEAN> { type = Type.BOOLEAN; } |
        <CHAR> { type = Type.CHAR; } |
        <INT> { type = Type.INT; } |
        <DOUBLE> {type = Type.DOUBLE; }
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return type; }
}

/**
 * Parse a reference type.
 * 
 * <pre>
 *   referenceType ::= basicType LBRACK RBRACK {LBRACK RBRACK}
 *                   | qualifiedIdentifier {LBRACK RBRACK}
 * </pre>
 * 
 * @return an instance of Type.
 */

private Type referenceType(): {
    Type type = Type.ANY;
}
{
    try {
        type = basicType()
        <LBRACK> <RBRACK> { type = new ArrayTypeName( type ); }
        ( 
            <LBRACK> <RBRACK> 
            { type = new ArrayTypeName( type ); } 
        )* |
        type = qualifiedIdentifier()
        ( 
            <LBRACK> <RBRACK> 
            { type = new ArrayTypeName( type ); } 
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return type; }       
}

/**
 * Parse a statement expression. 
 * 
 * <pre>
 *   statementExpression ::= expression // but must have 
 *                                      // side-effect, eg i++
 * </pre>
 * 
 * @return an AST for a statementExpression.
 */

private JStatement statementExpression(): {
    int line = 0;
    JExpression expr = null;
}
{
    try {
        expr = expression()
        {
            line = expr.line();
            if ( expr instanceof JAssignment
              || expr instanceof JPreIncrementOp
              || expr instanceof JPreDecrementOp
              || expr instanceof JPostIncrementOp
              || expr instanceof JPostDecrementOp
              || expr instanceof JMessageExpression
              || expr instanceof JSuperConstruction
              || expr instanceof JThisConstruction 
              || expr instanceof JNewOp
              || expr instanceof JNewArrayOp ) {
                // So as not to save on stack
                expr.isStatementExpression = true;
            }
            else {
                reportParserError( "Invalid statement expression; " + 
                    "it does not have a side-effect" );
            }
        }
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JStatementExpression( line, expr ); }
}

/**
 * An expression.
 * 
 * <pre>
 *   expression ::= assignmentExpression 
 * </pre>
 * 
 * @return an AST for an expression.
 */

private JExpression expression(): {
    JExpression expr = null;
}
{
    try {
        expr = assignmentExpression()
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse an assignment expression.
 * 
 * <pre>
 *   assignmentExpression ::= 
 *       conditionalAndExpression // level 13
 *           [( ASSIGN  // conditionalExpression
 *            | PLUS_ASSIGN // must be valid lhs
 *            )
 *            assignmentExpression]
 * </pre>
 * 
 * @return an AST for an assignmentExpression.
 */

private JExpression assignmentExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalExpression() { line = lhs.line(); }
        [       
            <ASSIGN> 
            rhs = assignmentExpression()
            { lhs = new JAssignOp( line, lhs, rhs ); } |
            <PLUS_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JPlusAssignOp( line, lhs, rhs ); }|
            <MINUS_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JMinusAssignOp( line, lhs, rhs ); }|
            <STAR_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JStarAssignOp( line, lhs, rhs ); }|
            <DIV_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JDivAssignOp( line, lhs, rhs ); }|
            <REM_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JRemAssignOp( line, lhs, rhs ); }
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}


/**
 * Parse a conditional expression.
 * 
 * <pre>
 *   // level 12
 *	 // conditionalExpression ::= conditionalOrExpression
 *                          // [TERNARY assignmentExpression : conditionalExpression]
 * </pre>
 * 
 * @return an AST for a conditionalExpression.
 */

private JExpression conditionalExpression(): {
    int line = 0;
    JExpression lhs = null, lrhs = null, rrhs = null;
}
{
    try {
        lhs = conditionalOrExpression() { line = lhs.line(); }
        [
            <TERNARY>
            lrhs = assignmentExpression()
            <COLON>
            rrhs = conditionalExpression()
            { lhs = new JConditionalExpressionOp(line, lhs, lrhs, rrhs);}
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}




/**
 * Parse a conditional OR expression.
 * 
 * <pre>
 *   conditionalOrExpression ::= conditinalAndExpression // level 11
 *                                  {|| conditinalAndExpression}
 * </pre>
 * 
 * @return an AST for a conditionalExpression.
 */

private JExpression conditionalOrExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalAndExpression() { line = lhs.line(); }
        ( 
            <LOR>
            rhs = conditionalAndExpression()
            { lhs = new JLogicalOrOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}


/**
 * Parse a conditional-and expression.
 * 
 * <pre>
 *   conditionalAndExpression ::= equalityExpression // level 10
 *                                  {LAND equalityExpression}
 * </pre>
 * 
 * @return an AST for a conditionalExpression.
 */

private JExpression conditionalAndExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = equalityExpression() { line = lhs.line(); }
        ( 
            <LAND>
            rhs = equalityExpression()
            { lhs = new JLogicalAndOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse an equality expression.
 * 
 * <pre>
 *   equalityExpression ::= relationalExpression  // level 6
 *                            {EQUAL relationalExpression}
 * </pre>
 * 
 * @return an AST for an equalityExpression.
 */

private JExpression equalityExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = relationalExpression() { line = lhs.line(); }
        ( 
            <EQUAL> 
            rhs = relationalExpression()
            { lhs = new JEqualOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse a relational expression.
 * 
 * <pre>
 *   relationalExpression ::= additiveExpression  // level 5
 *                              [(GT | LE) additiveExpression 
 *                              | INSTANCEOF referenceType]
 * </pre>
 * 
 * @return an AST for a relationalExpression.
 */

private JExpression relationalExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
    Type type = null;
}
{
    try {
        lhs = additiveExpression() { line = lhs.line(); }
        [ 
            <GT> 
            rhs = additiveExpression()
            { lhs = new JGreaterThanOp( line, lhs, rhs ); } |
            <LE> 
            rhs = additiveExpression()
            { lhs = new JLessEqualOp( line, lhs, rhs ); } |
            <INSTANCEOF> 
            type = referenceType()
            { lhs = new JInstanceOfOp( line, lhs, type ); }
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse an additive expression.
 * 
 * <pre>
 *   additiveExpression ::= multiplicativeExpression // level 3
 *                            {MINUS multiplicativeExpression}
 * </pre>
 * 
 * @return an AST for an additiveExpression.
 */

private JExpression additiveExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = multiplicativeExpression() { line = lhs.line(); } 
        ( 
            <PLUS> 
            rhs = multiplicativeExpression()
            { lhs = new JPlusOp( line, lhs, rhs ); } |
            <MINUS> 
            rhs = multiplicativeExpression()
            { lhs = new JSubtractOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse a multiplicative expression.
 * 
 * <pre>
 *   multiplicativeExpression ::= unaryExpression  // level 2
 *                                  {STAR unaryExpression}
 * </pre>
 * 
 * @return an AST for a multiplicativeExpression.
 */

private JExpression multiplicativeExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = unaryExpression() { line = lhs.line(); }
        ( 
            <STAR> 
            rhs = unaryExpression()
            { lhs = new JMultiplyOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse an unary expression.
 * 
 * <pre>
 *   unaryExpression ::= INC unaryExpression // level 1
 *                     | MINUS unaryExpression
 *                     | simpleUnaryExpression
 * </pre>
 * 
 * @return an AST for an unaryExpression.
 */

private JExpression unaryExpression(): {
    int line = 0;
    JExpression expr = null, unaryExpr = null;
}
{
    try {
    	// + unary
    	<PLUS> { line = token.beginLine; }
    	unaryExpr = unaryExpression()
    	{ expr = new JUnaryPlusOp(line, unaryExpr ); } |

    	// ++pre
        <INC> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JPreIncrementOp( line, unaryExpr ); } | 
        
        // -
        <MINUS> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JNegateOp( line, unaryExpr ); } |

        // --pre
        <DEC> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JPreDecrementOp( line, unaryExpr ); } |
        
        expr = simpleUnaryExpression()
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse a simple unary expression.
 * 
 * <pre>
 *   simpleUnaryExpression ::= LNOT unaryExpression
 *                           | LPAREN basicType RPAREN 
 *                               unaryExpression
 *                           | LPAREN         
 *                               referenceType
 *                             RPAREN simpleUnaryExpression
 *                           | postfixExpression
 * </pre>
 * 
 * @return an AST for a simpleUnaryExpression.
 */

private JExpression simpleUnaryExpression(): {
    int line = 0;
    Type type = null;
    JExpression expr = null, unaryExpr = null, simpleUnaryExpr = null;
}
{
    try {
        <LNOT> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JLogicalNotOp( line, unaryExpr ); } |
        LOOKAHEAD( <LPAREN> basicType() <RPAREN> )
        <LPAREN> { line = token.beginLine; }
        type = basicType() 
        <RPAREN>
        unaryExpr = unaryExpression()
        { expr = new JCastOp( line, type, unaryExpr ); } |
        LOOKAHEAD( <LPAREN> referenceType() <RPAREN> )
        <LPAREN> { line = token.beginLine; }
        type = referenceType() 
        <RPAREN>
        simpleUnaryExpr = simpleUnaryExpression()
        { expr = new JCastOp( line, type, simpleUnaryExpr ); } | 
        expr = postfixExpression() 
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr ; }
}

/**
 * Parse a postfix expression.
 * 
 * <pre>
 *   postfixExpression ::= primary {selector} {DEC|INC}
 * </pre>
 * 
 * @return an AST for a postfixExpression.
 */

private JExpression postfixExpression(): {
    int line = 0; 
    JExpression primaryExpr = null;
}
{
    try {
        primaryExpr = primary() { line = primaryExpr.line(); } 
        (
            primaryExpr = selector( primaryExpr ) 
        )*
        ( 
            <DEC> 
            { primaryExpr = 
                new JPostDecrementOp( line, primaryExpr ); } |
			<INC> 
            { primaryExpr = 
                new JPostIncrementOp( line, primaryExpr ); }
        )*
    } 
    catch ( ParseException e ) {
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return primaryExpr; }
}

/**
 * Parse a selector.
 * 
 * <pre>
 *   selector ::= DOT qualifiedIdentifier [arguments]
 *              | LBRACK expression RBRACK
 * </pre>
 * 
 * @param target the target expression for this selector.
 * @return an AST for a selector.
 */

private JExpression selector( JExpression target ): {       
    int line = 0;
    ArrayList<JExpression> args = null;
    TypeName id = null;
    JExpression expr = null;
}
{
    try {
        <DOT> { line = token.beginLine; } 
        id = qualifiedIdentifier()
        { expr = 
              new JFieldSelection( line, ambiguousPart( id ),
                                   target, id.simpleName() ); }
        [ 
            args = arguments() 
            { expr = new JMessageExpression( line, target, 
                  ambiguousPart( id ), id.simpleName(), args ); 
            } 
        ] |
        <LBRACK> { line = token.beginLine; }
        { expr = new JArrayExpression( line, target, expression() ); } 
        <RBRACK> 
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse a primary expression.
 * 
 * <pre>
 *   primary ::= parExpression
 *             | THIS [arguments]
 *             | SUPER ( arguments 
 *                     | DOT IDENTIFIER [arguments] 
 *                     )
 *             | literal
 *             | NEW creator
 *             | qualifiedIdentifier [arguments]
 * </pre>
 * 
 * @return an AST for a primary.
 */

private JExpression primary(): {
    int line = 0;
    JExpression expr = null;
    JExpression newTarget = null;
    ArrayList<JExpression> args = null;
    TypeName id = null;
}
{
    try {
        expr = parExpression() |
        <THIS> { line = token.beginLine; expr = new JThis( line ); }
        [ 
            args = arguments() 
            { expr = new JThisConstruction( line, args ); } 
        ] |
        <SUPER> { line = token.beginLine; }
        ( 
            args = arguments() 
            { expr = new JSuperConstruction( line, args ); } | 
            <DOT> <IDENTIFIER> 
            { 
                newTarget = new JSuper( line );
                expr = new JFieldSelection( line, newTarget, 
                                            token.image );
            }
            [ 
                args = arguments() 
                { expr = new JMessageExpression( line, newTarget, 
                      null, token.image, args ); }
            ] 
        ) |
        expr = literal() |
        <NEW> expr = creator() |

        // Language is ambiguous here. JavaCC warns about not being 
        // able to choose between qualifiedIdentifier and selector. 
        // Semantic analysis will sort it out.
        id = qualifiedIdentifier() 
        { 
            line = id.line(); 
            if ( ambiguousPart( id ) == null ) {
                expr = new JVariable( line, id.simpleName() );
            }
            else {
                expr = new JFieldSelection( line, ambiguousPart( id ), 
                                            null, id.simpleName() );             
            }
        } 
        [
            args = arguments()
            { expr = new JMessageExpression( line, null, 
                  ambiguousPart( id ), id.simpleName(), args ); }
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse a creator.
 * 
 * <pre>
 *   creator ::= (basicType | qualifiedIdentifier) 
 *                 ( arguments
 *                 | LBRACK RBRACK {LBRACK RBRACK} 
 *                     [arrayInitializer]
 *                 | newArrayDeclarator
 *                 )
 * </pre>
 * 
 * @return an AST for a creator.
 */

private JExpression creator(): {
    int line = 0;
    Type type = null;
    ArrayList<JExpression> args = null;
    ArrayList<JExpression> dims = null;
    JArrayInitializer init =  null;
    JExpression expr = null;
    Type expected = null;
}
{
    try {
        ( type = basicType() |
          type = qualifiedIdentifier() )
        { line = token.beginLine; expected = type; }
        (
            args = arguments()
            { expr = new JNewOp( line, type, args ); } |
            LOOKAHEAD( <LBRACK> expression() <RBRACK> )
            expr = newArrayDeclarator( type ) |
            <LBRACK> <RBRACK> { expected = new ArrayTypeName( expected
    ); }
            (
                LOOKAHEAD( <LBRACK> <RBRACK> )
                <LBRACK> <RBRACK>
                { expected = new ArrayTypeName( expected ); }
            )*
            [
               expr = arrayInitializer( expected )
            ]
        )
    }
    catch ( ParseException e ) {
        expr = new JWildExpression( token.beginLine );
        recoverFromError( new int[] { SEMI, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse a new array declarator.
 * 
 * <pre>
 *   newArrayDeclarator ::= LBRACK expression RBRACK 
 *                            {LBRACK expression RBRACK}
 *                            {LBRACK RBRACK}
 * </pre>
 * 
 * @param line line in which the declarator occurred.
 * @param type type of the array.
 * @return an AST for a newArrayDeclarator.
 */

private JNewArrayOp newArrayDeclarator( Type type ): {
    int line = 0;
    ArrayList<JExpression> dimensions = new ArrayList<JExpression>();
    JExpression expr = null;
}
{
    try {
        <LBRACK> { line = token.beginLine; } 
        expr = expression() 
        { dimensions.add( expr ); type = new ArrayTypeName( type ); }
        <RBRACK>
        ( 
            LOOKAHEAD( <LBRACK> expression() <RBRACK> )
            <LBRACK> 
            expr = expression() 
            { dimensions.add( expr); type = new ArrayTypeName( type ); } 
            <RBRACK> 
        )*
        (
            LOOKAHEAD( <LBRACK> <RBRACK> )
            <LBRACK> <RBRACK> { type = new ArrayTypeName( type ); }
        )*
    } 
    catch ( ParseException e ) {
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JNewArrayOp( line, type, dimensions ); }
}

/**
 * Parse a literal.
 * 
 * <pre>
 *   literal ::= INT_LITERAL | DOUBLE_LITERAL | CHAR_LITERAL | STRING_LITERAL
 *             | TRUE        | FALSE        | NULL
 * </pre>
 * 
 * @return an AST for a literal.
 */

private JExpression literal(): {
    JExpression expr = null;
}
{       
    try {
        <INT_LITERAL> 
        { expr = new JLiteralInt( token.beginLine, token.image ); } |
		<DOUBLE_LITERAL>
		{ expr = new JLiteralDouble( token.beginLine, token.image ); } |
        <CHAR_LITERAL> 
        { expr = new JLiteralChar( token.beginLine, token.image ); } |
        <STRING_LITERAL> 
        { expr = 
              new JLiteralString( token.beginLine, token.image ); } | 
        <TRUE> 
        { expr = new JLiteralTrue( token.beginLine ); } | 
        <FALSE> 
        { expr = new JLiteralFalse( token.beginLine ); } |
        <NULL> 
        { expr = new JLiteralNull( token.beginLine ); }
    } 
    catch ( ParseException e ) { 
        expr = new JWildExpression( token.beginLine ); 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}
